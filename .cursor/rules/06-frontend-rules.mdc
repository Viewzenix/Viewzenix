---
description: 
globs: 
alwaysApply: false
---
# Frontend Development Rules

## ðŸ” Overview
This rule defines specific guidelines and best practices for frontend development in the Viewzenix platform, focusing on React, TypeScript, and UI/UX standards.

## ðŸ§© Component Architecture

### Component Organization

```
src/components/
â”œâ”€â”€ common/               # Shared UI components
â”‚   â”œâ”€â”€ Button/
â”‚   â”‚   â”œâ”€â”€ Button.tsx    # Component implementation
â”‚   â”‚   â”œâ”€â”€ Button.test.tsx # Component tests
â”‚   â”‚   â””â”€â”€ index.ts      # Export file
â”‚   â””â”€â”€ ...
â”œâ”€â”€ feature-specific/     # Feature-specific components
â”‚   â”œâ”€â”€ WebhookForm/
â”‚   â””â”€â”€ ...
â””â”€â”€ layout/               # Layout components
    â”œâ”€â”€ Header/
    â””â”€â”€ ...
```

### Component Structure

```tsx
// âœ… GOOD: Well-structured component
import React, { useState, useEffect } from 'react';
import { useOrderData } from '../../hooks/useOrderData';
import { Button } from '../common/Button';
import './OrderCard.css';

// Define prop interface
interface OrderCardProps {
  orderId: string;
  onCancel?: (id: string) => void;
}

// Component implementation
export function OrderCard({ orderId, onCancel }: OrderCardProps) {
  // State and hooks
  const { data, loading, error } = useOrderData(orderId);
  const [isExpanded, setIsExpanded] = useState(false);
  
  // Event handlers
  const handleCancel = () => {
    if (onCancel) onCancel(orderId);
  };
  
  // Render helpers
  const renderStatus = () => (
    <span className={`status status-${data?.status}`}>
      {data?.status}
    </span>
  );
  
  // Loading and error states
  if (loading) return <div className="order-card-skeleton" />;
  if (error) return <div className="order-card-error">Failed to load order</div>;
  if (!data) return null;
  
  // Main render
  return (
    <div className="order-card" data-testid="order-card">
      <div className="order-header">
        <h3>{data.symbol}</h3>
        {renderStatus()}
      </div>
      
      <div className="order-details">
        <span>Quantity: {data.quantity}</span>
        <span>Price: ${data.price}</span>
      </div>
      
      {isExpanded && (
        <div className="order-expanded">
          {/* Additional details */}
        </div>
      )}
      
      <div className="order-actions">
        <Button onClick={() => setIsExpanded(!isExpanded)}>
          {isExpanded ? 'Show Less' : 'Show More'}
        </Button>
        <Button variant="danger" onClick={handleCancel}>Cancel</Button>
      </div>
    </div>
  );
}
```

## ðŸ“± Responsive Design

### Breakpoints

```css
/* Mobile: < 768px */
@media (max-width: 767px) {
  .container {
    padding: 0 16px;
  }
}

/* Tablet: 768px - 1023px */
@media (min-width: 768px) and (max-width: 1023px) {
  .container {
    padding: 0 24px;
  }
}

/* Desktop: >= 1024px */
@media (min-width: 1024px) {
  .container {
    padding: 0 32px;
    max-width: 1200px;
    margin: 0 auto;
  }
}
```

### Mobile-First Approach

- Start with mobile layout and progressively enhance for larger screens
- Use flexible layouts (flexbox, grid) for automatic content adjustment
- Ensure touch targets are at least 44x44px for mobile usability

## ðŸŽ¨ UI Design Patterns

### Form Design

```tsx
// âœ… GOOD: Form with validation
export function WebhookForm() {
  const [formData, setFormData] = useState({
    passphrase: '',
    webhookUrl: 'https://api.viewzenix.com/webhook'
  });
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
    
    // Clear error when field is modified
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: undefined }));
    }
  };
  
  const validate = () => {
    const newErrors = {};
    
    if (!formData.passphrase) {
      newErrors.passphrase = 'Passphrase is required';
    } else if (formData.passphrase.length < 8) {
      newErrors.passphrase = 'Passphrase must be at least 8 characters';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!validate()) return;
    
    setIsSubmitting(true);
    try {
      await saveWebhookSettings(formData);
      toast.success('Webhook settings saved');
    } catch (error) {
      toast.error('Failed to save webhook settings');
      console.error(error);
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <div className="form-group">
        <label htmlFor="passphrase">Passphrase</label>
        <input
          id="passphrase"
          name="passphrase"
          type="text"
          value={formData.passphrase}
          onChange={handleChange}
          className={errors.passphrase ? 'input-error' : ''}
          aria-invalid={!!errors.passphrase}
          aria-describedby={errors.passphrase ? 'passphrase-error' : undefined}
        />
        {errors.passphrase && (
          <div id="passphrase-error" className="error-message">
            {errors.passphrase}
          </div>
        )}
      </div>
      
      <div className="form-group">
        <label htmlFor="webhookUrl">Webhook URL</label>
        <div className="input-with-copy">
          <input
            id="webhookUrl"
            name="webhookUrl"
            type="text"
            value={formData.webhookUrl}
            readOnly
          />
          <Button 
            onClick={() => copyToClipboard(formData.webhookUrl)}
            icon="copy"
            aria-label="Copy to clipboard"
          />
        </div>
      </div>
      
      <Button 
        type="submit" 
        disabled={isSubmitting}
        loading={isSubmitting}
      >
        Save Settings
      </Button>
    </form>
  );
}
```

### Loading States

```tsx
// âœ… GOOD: Loading state pattern
export function DataTable({ fetchData }) {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const loadData = async () => {
      try {
        setLoading(true);
        setError(null);
        const result = await fetchData();
        setData(result);
      } catch (err) {
        setError('Failed to load data');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };
    
    loadData();
  }, [fetchData]);
  
  if (loading) {
    return <Skeleton rows={5} />;
  }
  
  if (error) {
    return <ErrorMessage message={error} onRetry={() => setLoading(true)} />;
  }
  
  if (data.length === 0) {
    return <EmptyState message="No data available" />;
  }
  
  return (
    <table className="data-table">
      {/* Table content */}
    </table>
  );
}
```

## ðŸƒâ€â™‚ï¸ Performance Optimization

### Memoization

```tsx
// âœ… GOOD: Proper use of memoization
import React, { useMemo, useCallback } from 'react';

function PerformanceList({ items, onItemClick }) {
  // Memoize expensive calculations
  const sortedItems = useMemo(() => {
    return [...items].sort((a, b) => a.name.localeCompare(b.name));
  }, [items]);
  
  // Memoize event handlers
  const handleItemClick = useCallback((id) => {
    onItemClick(id);
  }, [onItemClick]);
  
  return (
    <ul>
      {sortedItems.map(item => (
        <li key={item.id} onClick={() => handleItemClick(item.id)}>
          {item.name}
        </li>
      ))}
    </ul>
  );
}

// Use React.memo for component memoization
const MemoizedComponent = React.memo(PerformanceList);
```

### Code Splitting

```tsx
// âœ… GOOD: Code splitting with React.lazy
import React, { Suspense, lazy } from 'react';

// Lazy-loaded components
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Settings = lazy(() => import('./pages/Settings'));
const Reports = lazy(() => import('./pages/Reports'));

function App() {
  return (
    <Router>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/" element={<Dashboard />} />
          <Route path="/settings" element={<Settings />} />
          <Route path="/reports" element={<Reports />} />
        </Routes>
      </Suspense>
    </Router>
  );
}
```

## ðŸ§ª Frontend Testing

### Component Testing

```tsx
// âœ… GOOD: Component test with React Testing Library
import { render, screen, fireEvent } from '@testing-library/react';
import { OrderCard } from './OrderCard';

describe('OrderCard', () => {
  const mockOrder = {
    id: 'order-123',
    symbol: 'AAPL',
    quantity: 10,
    price: 150.5,
    status: 'open'
  };
  
  it('renders order details correctly', () => {
    render(<OrderCard order={mockOrder} />);
    
    expect(screen.getByText('AAPL')).toBeInTheDocument();
    expect(screen.getByText('Quantity: 10')).toBeInTheDocument();
    expect(screen.getByText('$150.50')).toBeInTheDocument();
    expect(screen.getByText('open')).toBeInTheDocument();
  });
  
  it('calls onCancel when cancel button is clicked', () => {
    const handleCancel = jest.fn();
    render(<OrderCard order={mockOrder} onCancel={handleCancel} />);
    
    fireEvent.click(screen.getByText('Cancel'));
    expect(handleCancel).toHaveBeenCalledWith('order-123');
  });
  
  it('expands when "Show More" is clicked', () => {
    render(<OrderCard order={mockOrder} />);
    
    expect(screen.queryByTestId('order-expanded')).not.toBeInTheDocument();
    
    fireEvent.click(screen.getByText('Show More'));
    expect(screen.getByTestId('order-expanded')).toBeInTheDocument();
    
    fireEvent.click(screen.getByText('Show Less'));
    expect(screen.queryByTestId('order-expanded')).not.toBeInTheDocument();
  });
});
```

## ðŸŽ¨ Figma Design Integration

### Component Implementation with Figma

```tsx
// âœ… GOOD: Fetching design assets from Figma
import React from 'react';

export function DesignSystemSetup() {
  // Fetch design tokens from Figma
  async function importDesignTokens() {
    const figmaFileKey = process.env.FIGMA_FILE_KEY;
    const nodeId = 'design-tokens';
    
    try {
      // Get Figma data using Framelink-Figma MCP
      const figmaData = await getFigmaData(figmaFileKey, nodeId);
      
      // Process color tokens
      const colorTokens = extractColorTokens(figmaData);
      
      // Save tokens to theme file
      generateThemeFile(colorTokens);
      
      return true;
    } catch (error) {
      console.error('Failed to import design tokens', error);
      return false;
    }
  }
  
  return (
    <div className="design-system-setup">
      <h2>Design System Configuration</h2>
      <button onClick={importDesignTokens}>
        Import Design Tokens from Figma
      </button>
    </div>
  );
}
```

### Asset Management

```tsx
// âœ… GOOD: Downloading and using Figma assets
import React, { useEffect, useState } from 'react';

export function AssetManager() {
  const [assetStatus, setAssetStatus] = useState('idle');
  
  async function downloadFigmaAssets() {
    const figmaFileKey = process.env.FIGMA_FILE_KEY;
    const iconNodes = ['icon-dashboard', 'icon-settings', 'icon-trading'];
    
    try {
      setAssetStatus('downloading');
      
      // Download icons from Figma using Framelink-Figma MCP
      await downloadFigmaImages(figmaFileKey, 
        iconNodes.map(node => ({
          nodeId: node,
          fileName: `${node}.svg`
        })),
        'src/assets/icons'
      );
      
      setAssetStatus('success');
    } catch (error) {
      console.error('Failed to download assets', error);
      setAssetStatus('error');
    }
  }
  
  return (
    <div className="asset-manager">
      <button 
        onClick={downloadFigmaAssets}
        disabled={assetStatus === 'downloading'}
      >
        {assetStatus === 'downloading' ? 'Downloading...' : 'Download Assets'}
      </button>
      {assetStatus === 'success' && <div className="success-message">Assets updated!</div>}
    </div>
  );
}
```

## âœ… Verification Steps

When developing frontend components, verify:

1. The component follows the established structure and organization
2. Proper type definitions are used for props and state
3. The component handles loading, error, and empty states
4. The UI is responsive across different screen sizes
5. Performance optimizations are applied where appropriate
6. Accessibility requirements are met (semantic HTML, ARIA attributes)
7. The component is covered by appropriate tests

## ðŸ”— Related Rules
[01-directory-structure.mdc](mdc:.cursor/rules/01-directory-structure.mdc)
[02-coding-standards.mdc](mdc:.cursor/rules/02-coding-standards.mdc)
