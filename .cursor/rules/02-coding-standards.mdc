---
description: Follow language-specific standards and patterns when writing code to ensure maintainability and quality
globs: ["**/*.{ts,tsx,js,jsx,py}"]
alwaysApply: true
---

# Coding Standards

## üîç Overview
This rule defines essential coding standards and style guidelines for the Viewzenix project, ensuring code consistency, maintainability, and quality across both frontend and backend components.

## üåü Core Principles

| Principle | Definition | How to Apply |
|-----------|------------|--------------|
| **DRY** | Don't Repeat Yourself | Extract reusable functions/components |
| **KISS** | Keep It Simple | Choose the simplest viable solution |
| **YAGNI** | You Aren't Gonna Need It | Only implement current requirements |
| **Single Responsibility** | One purpose per module | Split complex logic into focused units |
| **Testability** | Easy to test | Write code with clear inputs/outputs |

## üíª Language-Specific Standards

### TypeScript/React (Frontend)

#### Code Style

```typescript
// ‚úÖ GOOD: Type definitions
interface OrderProps {
  orderId: string;
  symbol: string;
  quantity: number;
  price: number;
  status: 'open' | 'filled' | 'canceled';
}

// ‚úÖ GOOD: Functional component with proper typing
function OrderCard({ orderId, symbol, quantity, price, status }: OrderProps) {
  // Use destructuring for props
  const formattedPrice = useMemo(() => formatCurrency(price), [price]);
  
  // Early return for error states
  if (!orderId) return <div className="error-state">Invalid order</div>;
  
  return (
    <div className="order-card" data-testid="order-card">
      <h3>{symbol}</h3>
      <div className="order-details">
        <span>Quantity: {quantity}</span>
        <span>Price: {formattedPrice}</span>
        <Badge status={status} />
      </div>
    </div>
  );
}

// ‚úÖ GOOD: Custom hook
function useOrderStatus(orderId: string) {
  const [status, setStatus] = useState<'open' | 'filled' | 'canceled'>('open');
  
  useEffect(() => {
    // Implementation details...
    
    return () => {
      // Cleanup logic
    };
  }, [orderId]);
  
  return status;
}

// ‚ùå BAD: Type any
function processOrder(order: any) { ... } // Avoid using 'any'

// ‚ùå BAD: Class components (prefer functional)
class OrderComponent extends React.Component { ... }
```

#### Key Rules
- Use TypeScript for all new code
- 2-space indentation, 100 character line limit
- Functional components with hooks instead of classes
- Explicit type definitions (no `any`, use proper interfaces)
- Use meaningful variable/function names
- Add data-testid to components for testing

### Python (Backend)

#### Code Style

```python
# ‚úÖ GOOD: Type annotations
from typing import Dict, List, Optional

# ‚úÖ GOOD: Function with type hints
def process_webhook_payload(payload: Dict[str, any]) -> Dict[str, any]:
    """
    Process incoming webhook payload from TradingView.
    
    Args:
        payload: The JSON payload from TradingView webhook
        
    Returns:
        Processed order object ready for broker submission
    
    Raises:
        ValidationError: If payload is malformed
    """
    # Implementation...
    return processed_order

# ‚úÖ GOOD: Class with proper methods
class OrderEngine:
    def __init__(self, broker_adapter):
        self.broker_adapter = broker_adapter
        self.logger = logging.getLogger("viewzenix.order_engine")
    
    def place_order(self, order_data: Dict[str, any]) -> str:
        """Place order through broker adapter"""
        try:
            return self.broker_adapter.submit_order(order_data)
        except BrokerError as e:
            self.logger.error(f"Failed to place order: {e}")
            raise OrderPlacementError(f"Broker error: {e}")

# ‚ùå BAD: No type hints
def process_data(data):  # Missing type hints
    return {"result": data}  # Missing return type

# ‚ùå BAD: Non-descriptive variable names
def p(d):  # Unclear function and variable names
    x = d["amt"] * 100  # Non-descriptive variable
    return x
```

#### Key Rules
- Follow PEP 8 style guide
- 4-space indentation, 88 character line limit
- Type annotations for function parameters and returns
- Docstrings for all public functions and classes
- Exception handling with specific exception types
- Descriptive variable and function names

## üîí Error Handling

### Frontend

```typescript
// ‚úÖ GOOD: Error handling with user feedback
try {
  const result = await api.sendOrder(orderData);
  setOrderStatus('submitted');
} catch (error) {
  // Specific error handling
  if (error.response?.status === 400) {
    setError('Invalid order data. Please check your inputs.');
  } else if (error.response?.status === 401) {
    setError('Authentication error. Please log in again.');
  } else {
    setError('Failed to submit order. Please try again later.');
    // Log for debugging
    console.error('Order submission error:', error);
  }
}
```

### Backend

```python
# ‚úÖ GOOD: Structured error response
@app.errorhandler(ValidationError)
def handle_validation_error(error):
    return {
        "error": {
            "code": "VALIDATION_ERROR",
            "message": str(error),
            "details": error.details if hasattr(error, "details") else {}
        }
    }, 400

# ‚úÖ GOOD: Try/except with logging and specific error types
try:
    result = process_webhook_data(data)
    return jsonify(result), 200
except ValidationError as e:
    logger.warning(f"Validation error: {e}")
    return jsonify({"error": {"code": "VALIDATION_ERROR", "message": str(e)}}), 400
except Exception as e:
    logger.error(f"Unexpected error processing webhook: {e}", exc_info=True)
    return jsonify({"error": {"code": "SERVER_ERROR", "message": "An unexpected error occurred"}}), 500
```

## üìä Logging

### Frontend
- Use console methods appropriately (debug, info, warn, error)
- Remove debug logs in production
- Include context in error logs

### Backend
- Configure structured logging with context
- Use appropriate log levels (DEBUG, INFO, WARNING, ERROR)
- Include request IDs in logs for traceability
- Log security events separately

## ‚úÖ Verification Steps

When writing or reviewing code, verify:

1. All new code follows the language-specific style guidelines
2. Functions and components follow the single responsibility principle
3. Error handling is implemented appropriately
4. Logging is used correctly for the context
5. No use of deprecated patterns
6. All code is properly typed (TypeScript) or type-hinted (Python)
7. Tests exist for new functionality

## üîó Related Rules
[01-directory-structure.mdc](mdc:.cursor/rules/01-directory-structure.mdc)
[03-workflow-processes.mdc](mdc:.cursor/rules/03-workflow-processes.mdc)
[09-advanced-development-guidelines.mdc](mdc:.cursor/rules/09-advanced-development-guidelines.mdc)