---
description: Implement specialized trading features when developing advanced platform capabilities
globs: 
alwaysApply: false
---

# Specialized Functionality

## üîç Overview
This rule provides detailed implementation guidelines for specialized functionality in the Viewzenix trading webhook platform. These include advanced trading features, integration patterns, and platform-specific implementation details.

## üìà Trading Functionality

### Order Types
Implement the following order types:

| Order Type | Description | Implementation Priority |
|------------|-------------|------------------------|
| Market | Execute at current market price | Critical |
| Limit | Execute at specified price or better | Critical |
| Stop | Market order when price reaches trigger | High |
| Stop-Limit | Limit order when price reaches trigger | High |
| Trailing Stop | Stop that follows price by percentage/amount | Medium |
| OCO (One-Cancels-Other) | Pair of orders where execution of one cancels the other | Low |

#### Market Order Implementation
```python
def place_market_order(broker_adapter, symbol, quantity, side):
    """
    Place a market order.
    
    Args:
        broker_adapter: The broker adapter to use
        symbol: The trading symbol
        quantity: Order quantity
        side: 'buy' or 'sell'
    
    Returns:
        Order details from broker
    """
    order_params = {
        'symbol': symbol,
        'qty': quantity,
        'side': side,
        'type': 'market',
        'time_in_force': 'gtc'
    }
    
    return broker_adapter.place_order(order_params)
```

#### Limit Order Implementation
```python
def place_limit_order(broker_adapter, symbol, quantity, side, limit_price):
    """
    Place a limit order.
    
    Args:
        broker_adapter: The broker adapter to use
        symbol: The trading symbol
        quantity: Order quantity
        side: 'buy' or 'sell'
        limit_price: The limit price
    
    Returns:
        Order details from broker
    """
    order_params = {
        'symbol': symbol,
        'qty': quantity,
        'side': side,
        'type': 'limit',
        'time_in_force': 'gtc',
        'limit_price': limit_price
    }
    
    return broker_adapter.place_order(order_params)
```

### Position Sizing Algorithms
Implement the following position sizing methods:

| Method | Description | Implementation |
|--------|-------------|----------------|
| Fixed Percentage | Use fixed percentage of account | `quantity = (account_value * percentage) / current_price` |
| Fixed Dollar Amount | Use fixed dollar amount | `quantity = dollar_amount / current_price` |
| Volatility-Based | Size based on volatility (ATR) | `quantity = (account_value * risk_pct) / (atr * atr_multiplier)` |
| Kelly Criterion | Optimal position sizing | `size = (win_rate - ((1 - win_rate) / payoff_ratio)) * account_value` |

#### Position Sizing Implementation
```python
def calculate_position_size(method, account_value, current_price, **kwargs):
    """
    Calculate position size based on specified method.
    
    Args:
        method: Position sizing method
        account_value: Current account value
        current_price: Current price of the asset
        **kwargs: Additional parameters needed for specific methods
    
    Returns:
        Quantity to trade
    """
    if method == 'fixed_percentage':
        percentage = kwargs.get('percentage', 0.02)  # Default 2%
        return (account_value * percentage) / current_price
        
    elif method == 'fixed_dollar':
        dollar_amount = kwargs.get('dollar_amount', 1000)  # Default $1000
        return dollar_amount / current_price
        
    elif method == 'volatility':
        risk_pct = kwargs.get('risk_pct', 0.01)  # Default 1%
        atr = kwargs.get('atr', 1.0)  # Must be provided
        atr_multiplier = kwargs.get('atr_multiplier', 2.0)
        return (account_value * risk_pct) / (atr * atr_multiplier)
        
    elif method == 'kelly':
        win_rate = kwargs.get('win_rate', 0.5)
        payoff_ratio = kwargs.get('payoff_ratio', 1.0)
        kelly_pct = max(0, win_rate - ((1 - win_rate) / payoff_ratio))
        # Usually apply a fraction of Kelly (half Kelly)
        fractional_kelly = kelly_pct * 0.5
        return (account_value * fractional_kelly) / current_price
        
    else:
        raise ValueError(f"Unknown position sizing method: {method}")
```

## üîå Broker Integration

### Alpaca API Integration
```python
import alpaca_trade_api as tradeapi
from alpaca_trade_api.rest import APIError

class AlpacaAdapter:
    """Adapter for Alpaca API."""
    
    def __init__(self, api_key=None, api_secret=None, base_url=None):
        """
        Initialize Alpaca adapter.
        
        Args:
            api_key: Alpaca API key
            api_secret: Alpaca API secret
            base_url: Alpaca API base URL
        """
        # Use provided credentials or load from environment
        self.api_key = api_key or os.environ.get('ALPACA_API_KEY')
        self.api_secret = api_secret or os.environ.get('ALPACA_API_SECRET')
        self.base_url = base_url or os.environ.get('ALPACA_API_BASE_URL')
        
        if not self.api_key or not self.api_secret:
            raise ValueError("Alpaca API credentials not provided")
            
        self.api = tradeapi.REST(
            key_id=self.api_key,
            secret_key=self.api_secret,
            base_url=self.base_url
        )
    
    def get_account(self):
        """Get account information."""
        try:
            return self.api.get_account()
        except APIError as e:
            raise BrokerConnectionError(f"Failed to get account: {str(e)}")
    
    def place_order(self, order_params):
        """
        Place an order with Alpaca.
        
        Args:
            order_params: Dictionary with order parameters
        
        Returns:
            Order object from Alpaca
        """
        try:
            return self.api.submit_order(
                symbol=order_params['symbol'],
                qty=order_params['qty'],
                side=order_params['side'],
                type=order_params['type'],
                time_in_force=order_params['time_in_force'],
                limit_price=order_params.get('limit_price'),
                stop_price=order_params.get('stop_price')
            )
        except APIError as e:
            raise BrokerConnectionError(f"Failed to place order: {str(e)}")
```

## üîí Risk Management

### Stop-Loss and Take-Profit Algorithms
Implement the following SL/TP methods:

| Method | Description | Implementation |
|--------|-------------|----------------|
| Fixed Percentage | SL/TP at fixed percentage from entry | `sl_price = entry_price * (1 - sl_pct)` |
| ATR-Based | SL/TP based on Average True Range | `sl_price = entry_price - (atr * atr_multiplier)` |
| Support/Resistance | SL/TP at nearby support/resistance | Use technical analysis to identify levels |
| Moving Average | SL follows a moving average | Update SL as MA changes |

#### SL/TP Implementation
```python
def calculate_stop_loss(method, entry_price, side, **kwargs):
    """
    Calculate stop loss price based on method.
    
    Args:
        method: Stop loss method
        entry_price: Entry price
        side: 'buy' or 'sell'
        **kwargs: Additional parameters
    
    Returns:
        Stop loss price
    """
    multiplier = -1 if side == 'buy' else 1
    
    if method == 'fixed_percentage':
        percentage = kwargs.get('sl_percentage', 0.02)  # Default 2%
        return entry_price * (1 + (multiplier * percentage))
        
    elif method == 'atr':
        atr = kwargs.get('atr', 1.0)
        atr_multiplier = kwargs.get('atr_multiplier', 2.0)
        return entry_price + (multiplier * atr * atr_multiplier)
        
    else:
        raise ValueError(f"Unknown stop loss method: {method}")
```

### Global Risk Management
```python
class RiskManager:
    """Global risk management service."""
    
    def __init__(self, max_position_pct=0.05, max_correlated_pct=0.15, max_daily_loss_pct=0.03):
        """
        Initialize risk manager.
        
        Args:
            max_position_pct: Maximum allocation for any single position
            max_correlated_pct: Maximum allocation for correlated assets
            max_daily_loss_pct: Maximum daily loss threshold
        """
        self.max_position_pct = max_position_pct
        self.max_correlated_pct = max_correlated_pct
        self.max_daily_loss_pct = max_daily_loss_pct
        
    def check_position_limit(self, account_value, position_value):
        """Check if position exceeds single position limit."""
        position_pct = position_value / account_value
        return position_pct <= self.max_position_pct
        
    def check_correlated_limit(self, account_value, correlated_positions_value):
        """Check if correlated positions exceed limit."""
        correlated_pct = correlated_positions_value / account_value
        return correlated_pct <= self.max_correlated_pct
        
    def check_daily_loss_limit(self, starting_value, current_value):
        """Check if daily loss limit has been reached."""
        daily_loss_pct = (starting_value - current_value) / starting_value
        return daily_loss_pct <= self.max_daily_loss_pct
```

## üîç Webhook Processing

### Payload Parsing

```python
def parse_webhook_payload(payload):
    """
    Parse TradingView webhook payload.
    
    Args:
        payload: JSON payload from TradingView
        
    Returns:
        Dictionary with parsed parameters
        
    Raises:
        InvalidJsonError: If payload is invalid
    """
    required_fields = ['passphrase', 'ticker', 'action']
    
    # Check required fields
    for field in required_fields:
        if field not in payload:
            raise InvalidJsonError(f"Missing required field: {field}")
    
    # Verify passphrase
    if payload['passphrase'] != os.environ.get('WEBHOOK_PASSPHRASE'):
        raise InvalidJsonError("Invalid passphrase")
    
    # Parse action
    action = payload['action'].upper()
    if action not in ['BUY', 'SELL', 'CLOSE']:
        raise InvalidJsonError(f"Invalid action: {action}")
    
    # Parse remaining fields
    result = {
        'ticker': payload['ticker'],
        'action': action,
        'quantity': payload.get('quantity'),
        'price': payload.get('price'),
        'order_type': payload.get('order_type', 'MARKET'),
        'stop_loss': payload.get('stop_loss'),
        'take_profit': payload.get('take_profit'),
        'time_in_force': payload.get('time_in_force', 'DAY')
    }
    
    return result
```

## üìä Analytics and Reporting

### Performance Metrics

Calculate the following performance metrics:

| Metric | Formula | Description |
|--------|---------|-------------|
| Win Rate | `wins / total_trades` | Percentage of winning trades |
| Profit Factor | `gross_profit / gross_loss` | Ratio of profit to loss |
| Sharpe Ratio | `(return - risk_free) / std_dev` | Risk-adjusted return |
| Drawdown | `(peak - trough) / peak` | Maximum loss from peak to trough |
| CAGR | `(ending / beginning)^(1/years) - 1` | Compound annual growth rate |

#### Performance Calculation
```python
def calculate_performance_metrics(trades):
    """
    Calculate performance metrics from trade history.
    
    Args:
        trades: List of trade objects with results
        
    Returns:
        Dictionary with performance metrics
    """
    if not trades:
        return {}
        
    wins = sum(1 for trade in trades if trade['profit'] > 0)
    losses = sum(1 for trade in trades if trade['profit'] <= 0)
    total_trades = len(trades)
    
    gross_profit = sum(trade['profit'] for trade in trades if trade['profit'] > 0)
    gross_loss = abs(sum(trade['profit'] for trade in trades if trade['profit'] < 0))
    
    # Prevent division by zero
    win_rate = wins / total_trades if total_trades > 0 else 0
    profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf')
    
    # Calculate average profit and standard deviation
    profits = [trade['profit'] for trade in trades]
    avg_profit = sum(profits) / len(profits) if profits else 0
    std_dev = (sum((p - avg_profit) ** 2 for p in profits) / len(profits)) ** 0.5 if profits else 0
    
    # Calculate Sharpe ratio (assuming zero risk-free rate)
    sharpe = avg_profit / std_dev if std_dev > 0 else 0
    
    # Calculate drawdown
    balance_curve = []
    balance = 100  # Starting with 100 for percentage calculation
    for trade in trades:
        balance += trade['profit']
        balance_curve.append(balance)
    
    max_drawdown = 0
    peak = balance_curve[0]
    
    for balance in balance_curve:
        if balance > peak:
            peak = balance
        else:
            drawdown = (peak - balance) / peak
            max_drawdown = max(max_drawdown, drawdown)
    
    return {
        'total_trades': total_trades,
        'win_rate': win_rate,
        'profit_factor': profit_factor,
        'sharpe_ratio': sharpe,
        'max_drawdown': max_drawdown,
        'net_profit': sum(profits)
    }
```

## ‚úÖ Verification Steps
When implementing specialized functionality, verify:

1. The implementation follows best practices for the specific functionality
2. Edge cases are properly handled
3. The implementation is efficient and optimized
4. Security considerations specific to trading are addressed
5. Documentation is comprehensive and includes examples

## üîó Related Rules
[04-technical-requirements.mdc](mdc:.cursor/rules/04-technical-requirements.mdc)
[07-backend-rules.mdc](mdc:.cursor/rules/07-backend-rules.mdc)
[08-integration-patterns.mdc](mdc:.cursor/rules/08-integration-patterns.mdc)
[09-advanced-development-guidelines.mdc](mdc:.cursor/rules/09-advanced-development-guidelines.mdc)
