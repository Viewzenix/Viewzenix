---
description: This rule defines standardized integration patterns for connecting different components of the Viewzenix trading webhook platform. It ensures reliable, secure, and efficient communication between frontend and backend, as well as with external systems.
globs: 
alwaysApply: false
---
# Integration Patterns

## üîç Overview
This rule defines standardized integration patterns for connecting different components of the Viewzenix trading webhook platform. It ensures reliable, secure, and efficient communication between frontend and backend, as well as with external systems.

## üåê API Integration Patterns

### RESTful API Standards
All internal and external API integrations should follow these standards:

- Use standard HTTP methods (GET, POST, PUT, DELETE)
- Return appropriate status codes
- Use consistent error response format
- Implement proper validation and sanitization
- Document all endpoints with examples

```javascript
// ‚úÖ GOOD: Standard API request
async function fetchOrders(filters) {
  try {
    const response = await fetch('/api/orders', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${getToken()}`
      },
      body: JSON.stringify(filters)
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(`API Error: ${errorData.message}`);
    }
    
    return await response.json();
  } catch (error) {
    // Error handling
    console.error('Failed to fetch orders:', error);
    throw error;
  }
}
```

### Frontend-Backend Integration
- Use service classes in the frontend to encapsulate API calls
- Implement retry logic for transient failures
- Handle token expiration and renewal
- Cache responses where appropriate

```typescript
// ‚úÖ GOOD: Service class pattern
export class OrderService {
  private static instance: OrderService;
  private baseUrl = '/api/orders';
  
  private constructor() {}
  
  public static getInstance(): OrderService {
    if (!OrderService.instance) {
      OrderService.instance = new OrderService();
    }
    return OrderService.instance;
  }
  
  async getOrders(filters: OrderFilters): Promise<Order[]> {
    // Implementation...
  }
  
  async submitOrder(order: OrderRequest): Promise<OrderResponse> {
    // Implementation...
  }
}

// Usage
const orderService = OrderService.getInstance();
const orders = await orderService.getOrders({ status: 'open' });
```

## üîå External System Integration

### Broker API Integration
- Use adapter pattern to normalize different broker APIs
- Implement circuit breakers for external API calls
- Handle rate limits and backpressure
- Log all external calls with correlation IDs

```python
# ‚úÖ GOOD: Broker adapter pattern
class BrokerAdapter(ABC):
    """Abstract base class for broker adapters."""
    
    @abstractmethod
    def get_account(self) -> dict:
        """Get account information from broker."""
        pass
    
    @abstractmethod
    def submit_order(self, order: dict) -> dict:
        """Submit an order to the broker."""
        pass

class AlpacaAdapter(BrokerAdapter):
    """Adapter for Alpaca API."""
    
    def __init__(self, api_key: str, api_secret: str, base_url: str):
        self.api = alpaca.REST(api_key, api_secret, base_url)
        self.logger = logging.getLogger("broker.alpaca")
    
    def get_account(self) -> dict:
        """Get account information from Alpaca."""
        try:
            account = self.api.get_account()
            return self._normalize_account(account)
        except Exception as e:
            self.logger.error(f"Failed to get account: {str(e)}")
            raise BrokerConnectionError(f"Failed to get account: {str(e)}")
    
    def submit_order(self, order: dict) -> dict:
        """Submit an order to Alpaca."""
        # Implementation...
```

### Webhook Integration
- Validate all incoming webhooks with proper authentication
- Process webhooks asynchronously when possible
- Implement idempotency to prevent duplicate processing
- Provide webhook testing tools

```python
# ‚úÖ GOOD: Webhook processing
@webhook_bp.route('', methods=['POST'])
def process_webhook():
    """Process incoming webhook."""
    # Generate correlation ID for request tracking
    correlation_id = str(uuid.uuid4())
    
    try:
        # Validate webhook signature/passphrase
        payload = request.get_json()
        if not validate_webhook_auth(payload):
            logger.warning(
                "Invalid webhook authentication",
                extra={"correlation_id": correlation_id}
            )
            return jsonify({
                "status": "error",
                "message": "Invalid authentication"
            }), 401
        
        # Check for duplicate webhook (idempotency)
        if is_duplicate_webhook(payload):
            logger.info(
                "Duplicate webhook received",
                extra={"correlation_id": correlation_id}
            )
            return jsonify({
                "status": "success",
                "message": "Webhook already processed"
            }), 200
        
        # Process webhook (async for long-running operations)
        process_webhook_task.delay(payload, correlation_id)
        
        return jsonify({
            "status": "success",
            "message": "Webhook received",
            "correlation_id": correlation_id
        }), 202
        
    except Exception as e:
        logger.error(
            f"Error processing webhook: {str(e)}",
            extra={"correlation_id": correlation_id},
            exc_info=True
        )
        return jsonify({
            "status": "error",
            "message": "Server error"
        }), 500
```

## üîÑ Real-time Data Integration

### WebSocket Integration
- Use WebSockets for real-time updates
- Implement proper authentication for socket connections
- Handle reconnection logic on disconnects
- Structure message formats consistently

```typescript
// ‚úÖ GOOD: WebSocket client implementation
export class WebSocketService {
  private socket: WebSocket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private listeners: Map<string, Function[]> = new Map();
  
  connect(token: string): void {
    this.socket = new WebSocket(`wss://api.viewzenix.com/ws?token=${token}`);
    
    this.socket.onopen = () => {
      console.log('WebSocket connected');
      this.reconnectAttempts = 0;
      this.emit('connected', {});
    };
    
    this.socket.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        this.emit(message.type, message.data);
      } catch (error) {
        console.error('Failed to parse WebSocket message', error);
      }
    };
    
    this.socket.onclose = () => {
      console.log('WebSocket disconnected');
      this.handleDisconnect();
    };
    
    this.socket.onerror = (error) => {
      console.error('WebSocket error', error);
      this.handleDisconnect();
    };
  }
  
  // Other methods...
}
```

## üîí Security Integration

### Authentication Integration
- Use OAuth 2.0 or JWT for authentication
- Implement proper token refresh mechanisms
- Secure all sensitive credentials
- Apply principle of least privilege

```typescript
// ‚úÖ GOOD: Authentication service
export class AuthService {
  private static instance: AuthService;
  private token: string | null = null;
  private refreshToken: string | null = null;
  private tokenExpiry: Date | null = null;
  
  private constructor() {
    // Load from secure storage if available
    this.loadTokensFromStorage();
  }
  
  public static getInstance(): AuthService {
    if (!AuthService.instance) {
      AuthService.instance = new AuthService();
    }
    return AuthService.instance;
  }
  
  async login(credentials: LoginCredentials): Promise<boolean> {
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials)
      });
      
      if (!response.ok) throw new Error('Login failed');
      
      const data = await response.json();
      this.setTokens(data.token, data.refreshToken, data.expiresIn);
      return true;
    } catch (error) {
      console.error('Login error:', error);
      return false;
    }
  }
  
  async getValidToken(): Promise<string | null> {
    if (this.isTokenExpired() && this.refreshToken) {
      await this.refreshAccessToken();
    }
    return this.token;
  }
  
  // Other methods...
}
```

## üß™ Automated Browser Testing

### Browser Automation with Stagehand

```typescript
// ‚úÖ GOOD: End-to-end testing with Stagehand
import { test, expect } from '@playwright/test';

test('User can log in and view dashboard', async ({ page }) => {
  // Navigation
  await page.goto('https://app.viewzenix.com/login');
  
  // Interaction with login form
  await page.fill('[data-testid="email-input"]', 'test@example.com');
  await page.fill('[data-testid="password-input"]', 'password123');
  await page.click('[data-testid="login-button"]');
  
  // Verification
  await expect(page.locator('[data-testid="dashboard-title"]')).toBeVisible();
  await expect(page.locator('[data-testid="account-summary"]')).toContainText('Account');
});
```

### Content Validation

```typescript
// ‚úÖ GOOD: Content extraction and validation
async function validateOrderSubmission() {
  // Navigate to trading form
  await navigate('https://app.viewzenix.com/trading');
  
  // Fill form using Stagehand actions
  await act('Fill the symbol input with AAPL');
  await act('Select Buy from the action dropdown');
  await act('Enter 10 in the quantity field');
  await act('Click the Submit Order button');
  
  // Extract content to verify submission
  const content = await extract();
  
  // Validate success message appears
  return content.includes('Order submitted successfully');
}
```

### Visual Testing

```typescript
// ‚úÖ GOOD: Visual comparison testing
import { expect } from '@playwright/test';

// Compare current state with baseline snapshot
async function compareVisualSnapshot(page, componentName) {
  // Take screenshot using Stagehand
  const screenshot = await page.screenshot();
  
  // Compare with baseline (implementation depends on testing framework)
  expect(screenshot).toMatchSnapshot(`${componentName}.png`);
}
```

## ‚úÖ Verification Steps
When implementing integrations, verify:

1. All integrations follow the defined patterns
2. Error handling is comprehensive
3. Security measures are properly implemented
4. Performance considerations are addressed
5. Logging and monitoring are in place

## üîó Related Rules
[01-directory-structure.mdc](mdc:.cursor/rules/01-directory-structure.mdc)
[06-frontend-rules.mdc](mdc:.cursor/rules/06-frontend-rules.mdc)
[07-backend-rules.mdc](mdc:.cursor/rules/07-backend-rules.mdc)

